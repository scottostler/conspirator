// Generated by CoffeeScript 1.8.0
(function() {
  var BasicAI, countInList, shuffle, stringify,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  BasicAI = (function() {
    function BasicAI() {
      this.copy = __bind(this.copy, this);
      this.herbalistValue = __bind(this.herbalistValue, this);
      this.trashOppTreasureValue = __bind(this.trashOppTreasureValue, this);
      this.putOnDeckValue = __bind(this.putOnDeckValue, this);
    }

    BasicAI.prototype.name = 'Basic AI';

    BasicAI.prototype.author = 'rspeer';

    BasicAI.prototype.myPlayer = function(state) {
      var player, _i, _len, _ref;
      _ref = state.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (player.ai === this) {
          return player;
        }
      }
      throw new Error("" + this + " is being asked to make a decision, but isn't playing the game...?");
    };

    BasicAI.prototype.choose = function(type, state, choices) {
      var bestChoice, bestValue, choice, choiceSet, my, nullable, preference, priority, priorityfunc, value, _i, _j, _k, _len, _len1, _len2;
      my = this.myPlayer(state);
      if (choices.length === 0) {
        return null;
      }
      priorityfunc = this[type + 'Priority'];
      if (priorityfunc != null) {
        choiceSet = {};
        for (_i = 0, _len = choices.length; _i < _len; _i++) {
          choice = choices[_i];
          choiceSet[choice] = choice;
        }
        nullable = __indexOf.call(choices, null) >= 0;
        priority = priorityfunc.call(this, state, my);
        for (_j = 0, _len1 = priority.length; _j < _len1; _j++) {
          preference = priority[_j];
          if (preference === null && nullable) {
            return null;
          }
          if (choiceSet[preference] != null) {
            return choiceSet[preference];
          }
        }
      }
      bestChoice = null;
      bestValue = -Infinity;
      for (_k = 0, _len2 = choices.length; _k < _len2; _k++) {
        choice = choices[_k];
        value = this.getChoiceValue(type, state, choice, my);
        if (value > bestValue) {
          bestValue = value;
          bestChoice = choice;
        }
      }
      if (__indexOf.call(choices, bestChoice) >= 0) {
        return bestChoice;
      }
      if (__indexOf.call(choices, null) >= 0) {
        return null;
      }
      throw new Error("" + this + " somehow failed to make a choice");
    };

    BasicAI.prototype.getChoiceValue = function(type, state, choice, my) {
      var defaultValueFunc, result, specificValueFunc;
      if (choice === null || choice === false) {
        return 0;
      }
      specificValueFunc = this[type + 'Value'];
      if (specificValueFunc != null) {
        result = specificValueFunc.call(this, state, choice, my);
        if (result === void 0) {
          throw new Error("" + this + " has an undefined " + type + " value for " + choice);
        }
        if (result !== null) {
          return result;
        }
      }
      defaultValueFunc = choice['ai_' + type + 'Value'];
      if (defaultValueFunc != null) {
        result = defaultValueFunc.call(choice, state, my);
        if (result === void 0) {
          throw new Error("" + this + " has an undefined " + type + " value for " + choice);
        }
        if (result !== null) {
          return result;
        }
      }
      state.warn("" + this + " doesn't know how to make a " + type + " decision for " + choice);
      return -1000;
    };

    BasicAI.prototype.choiceToValue = function(type, state, choice) {
      var index, my, priority, priorityfunc;
      if (choice === null || choice === false) {
        return 0;
      }
      my = this.myPlayer(state);
      priorityfunc = this[type + 'Priority'];
      if (priorityfunc != null) {
        priority = priorityfunc.bind(this)(state, my);
      } else {
        priority = [];
      }
      index = priority.indexOf(stringify(choice));
      if (index !== -1) {
        return (priority.length - index) * 100;
      } else {
        return this.getChoiceValue(type, state, choice, my);
      }
    };

    BasicAI.prototype.chooseAction = function(state, choices) {
      return this.choose('play', state, choices);
    };

    BasicAI.prototype.chooseTreasure = function(state, choices) {
      return this.choose('play', state, choices);
    };

    BasicAI.prototype.chooseGain = function(state, choices) {
      return this.choose('gain', state, choices);
    };

    BasicAI.prototype.chooseDiscard = function(state, choices) {
      return this.choose('discard', state, choices);
    };

    BasicAI.prototype.chooseTrash = function(state, choices) {
      return this.choose('trash', state, choices);
    };

    BasicAI.prototype.gainPriority = function(state, my) {
      var _ref, _ref1;
      return [my.countInDeck("Platinum") > 0 ? "Colony" : void 0, state.countInSupply("Colony") <= 6 ? "Province" : void 0, (0 < (_ref = state.gainsToEndGame()) && _ref <= 5) ? "Duchy" : void 0, (0 < (_ref1 = state.gainsToEndGame()) && _ref1 <= 2) ? "Estate" : void 0, "Platinum", "Gold", "Silver", state.gainsToEndGame() <= 3 ? "Copper" : void 0];
    };

    BasicAI.prototype.gainValue = function(state, card, my) {
      return card.cost + 2 * card.costPotion + card.isTreasure + card.isAction - 20;
    };

    BasicAI.prototype.old_actionPriority = function(state, my, skipMultipliers) {
      var card, choice, choice1, choices, countInHandCopper, currentAction, mult, multiplier, mults, okayToPlayMultiplier, wantsToPlayMultiplier, wantsToTrash, _ref, _ref1, _ref2;
      if (skipMultipliers == null) {
        skipMultipliers = false;
      }
      wantsToTrash = this.wantsToTrash(state);
      countInHandCopper = my.countInHand("Copper");
      currentAction = my.getCurrentAction();
      multiplier = 1;
      if (currentAction != null ? currentAction.isMultiplier : void 0) {
        multiplier = currentAction.multiplier;
      }
      wantsToPlayMultiplier = false;
      okayToPlayMultiplier = false;
      if (!skipMultipliers) {
        mults = (function() {
          var _i, _len, _ref, _results;
          _ref = my.hand;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            card = _ref[_i];
            if (card.isMultiplier) {
              _results.push(card);
            }
          }
          return _results;
        })();
        if (mults.length > 0) {
          mult = mults[0];
          choices = my.hand.slice(0);
          choices.remove(mult);
          choices.push(null);
          choice1 = this.choose('multipliedAction', state, choices);
          if (choice1 !== null) {
            okayToPlayMultiplier = true;
          }
          if (choices.length > 1) {
            choices.push("wait");
          }
          choice = this.choose('multipliedAction', state, choices);
          if (choice !== "wait") {
            wantsToPlayMultiplier = true;
          }
        }
      }
      return [my.menagerieDraws() === 3 ? "Menagerie" : void 0, my.shantyTownDraws(true) === 2 ? "Shanty Town" : void 0, my.countInHand("Province") > 0 ? "Tournament" : void 0, my.hand.length <= 3 && my.actions > 1 ? "Library" : void 0, wantsToPlayMultiplier ? "Throne Room" : void 0, wantsToPlayMultiplier ? "King's Court" : void 0, state.gainsToEndGame() >= 5 || (_ref = state.cardInfo.Curse, __indexOf.call(my.draw, _ref) >= 0) ? "Lookout" : void 0, "Cartographer", "Bag of Gold", "Apothecary", "Scout", "Scrying Pool", "Spy", "Trusty Steed", "Festival", "University", "Farming Village", "Bazaar", "Worker's Village", "City", "Walled Village", "Fishing Village", "Village", "Border Village", "Mining Village", "Grand Market", "Hunting Party", "Alchemist", "Laboratory", "Caravan", "Market", "Peddler", "Treasury", my.inPlay.length >= 2 || multiplier > 1 ? "Conspirator" : void 0, "Familiar", "Highway", "Scheme", "Wishing Well", "Golem", (_ref1 = state.cardInfo.Crossroads, __indexOf.call(my.hand, _ref1) < 0) ? "Great Hall" : void 0, (_ref2 = state.cardInfo.Copper, __indexOf.call(my.hand, _ref2) >= 0) ? "Spice Merchant" : void 0, this.choose('stablesDiscard', state, my.hand.concat([null])) ? "Stables" : void 0, "Apprentice", "Pearl Diver", "Hamlet", "Lighthouse", "Haven", "Minion", my.actions > 1 && my.hand.length <= 4 ? "Library" : void 0, my.actions > 1 ? "Torturer" : void 0, my.actions > 1 ? "Margrave" : void 0, my.actions > 1 ? "Rabble" : void 0, my.actions > 1 ? "Witch" : void 0, my.actions > 1 ? "Ghost Ship" : void 0, my.actions > 1 ? "Smithy" : void 0, my.actions > 1 ? "Embassy" : void 0, my.actions > 1 && my.hand.length <= 4 ? "Watchtower" : void 0, my.actions > 1 && my.hand.length <= 5 ? "Library" : void 0, my.actions > 1 ? "Council Room" : void 0, my.actions > 1 && (my.discard.length + my.draw.length) <= 3 ? "Courtyard" : void 0, my.actions > 1 ? "Oracle" : void 0, !(my.countInPlay(state.cardInfo.Crossroads) > 0) ? "Crossroads" : void 0, "Great Hall", wantsToTrash >= multiplier ? "Upgrade" : void 0, "Oasis", "Pawn", "Warehouse", "Cellar", my.actions > 1 && my.hand.length <= 6 ? "Library" : void 0, this.choose('spiceMerchantTrash', state, my.hand.concat([null])) ? "Spice Merchant" : void 0, "King's Court", okayToPlayMultiplier ? "Throne Room" : void 0, "Tournament", "Menagerie", my.actions < 2 ? "Shanty Town" : void 0, "Crossroads", "Nobles", my.countInHand("Treasure Map") >= 2 ? "Treasure Map" : void 0, "Followers", "Mountebank", "Witch", "Sea Hag", "Torturer", "Young Witch", "Tribute", "Margrave", "Goons", "Wharf", "Tactician", "Masquerade", "Vault", "Ghost Ship", "Princess", my.countInHand("Province") >= 1 ? "Explorer" : void 0, my.hand.length <= 3 ? "Library" : void 0, "Jester", "Militia", "Cutpurse", "Bridge", "Bishop", "Horse Traders", "Jack of All Trades", "Steward", countInHandCopper >= 1 ? "Moneylender" : void 0, "Expand", "Remodel", "Salvager", "Mine", countInHandCopper >= 3 ? "Coppersmith" : void 0, my.hand.length <= 4 ? "Library" : void 0, "Rabble", "Envoy", "Smithy", "Embassy", my.hand.length <= 3 ? "Watchtower" : void 0, "Council Room", my.hand.length <= 5 ? "Library" : void 0, my.hand.length <= 4 ? "Watchtower" : void 0, (my.discard.length + my.draw.length) > 0 ? "Courtyard" : void 0, "Merchant Ship", my.countInHand("Estate") >= 1 ? "Baron" : void 0, "Monument", "Oracle", wantsToTrash >= multiplier * 2 ? "Remake" : void 0, "Adventurer", "Harvest", "Haggler", "Mandarin", "Explorer", "Woodcutter", "Nomad Camp", "Chancellor", "Counting House", countInHandCopper >= 2 ? "Coppersmith" : void 0, state.extraturn === false ? "Outpost" : void 0, wantsToTrash ? "Ambassador" : void 0, wantsToTrash + my.countInHand("Silver") >= 2 * multiplier ? "Trading Post" : void 0, wantsToTrash ? "Chapel" : void 0, wantsToTrash >= multiplier ? "Trader" : void 0, wantsToTrash >= multiplier ? "Trade Route" : void 0, my.ai.choose('mint', state, my.hand) ? "Mint" : void 0, "Secret Chamber", "Pirate Ship", "Noble Brigand", "Thief", "Island", "Fortune Teller", "Bureaucrat", "Navigator", my.actions < 2 ? "Conspirator" : void 0, "Herbalist", "Moat", my.hand.length <= 6 ? "Library" : void 0, "Ironworks", "Workshop", state.smugglerChoices().length > 1 ? "Smugglers" : void 0, "Feast", wantsToTrash >= multiplier ? "Transmute" : void 0, "Coppersmith", "Saboteur", "Poor House", "Duchess", my.hand.length <= 7 ? "Library" : void 0, "Thief", my.countInDeck("Gold") >= 4 && state.current.countInDeck("Treasure Map") === 1 ? "Treasure Map" : void 0, "Spice Merchant", "Shanty Town", "Stables", "Chapel", "Library", "Conspirator", null, "Baron", "Mint", "Watchtower", "Outpost", "Ambassador", "Trader", "Transmute", "Trade Route", "Upgrade", "Remake", "Trading Post", "Treasure Map", "Throne Room"];
    };

    BasicAI.prototype.old_multipliedActionPriority = function(state, my) {
      var skipMultipliers;
      return ["King's Court", "Throne Room", my.actions > 0 ? "Followers" : void 0, "Grand Market", my.actions > 0 ? "Mountebank" : void 0, my.actions > 0 && state.countInSupply("Curse") >= 2 ? "Witch" : void 0, my.actions > 0 && state.countInSupply("Curse") >= 2 ? "Sea Hag" : void 0, my.actions > 0 && state.countInSupply("Curse") >= 2 ? "Torturer" : void 0, my.actions > 0 && state.countInSupply("Curse") >= 2 ? "Young Witch" : void 0, my.actions > 0 || my.countInPlay(state.cardInfo.Crossroads) === 0 ? "Crossroads" : void 0, my.countInDeck("King's Court") >= 2 ? "Scheme" : void 0, my.actions > 0 ? "Wharf" : void 0, my.actions > 0 ? "Bridge" : void 0, "Minion", my.actions > 0 ? "Ghost Ship" : void 0, my.actions > 0 ? "Jester" : void 0, my.actions > 0 ? "Horse Traders" : void 0, my.actions > 0 ? "Mandarin" : void 0, my.actions > 0 ? "Rabble" : void 0, my.actions > 0 ? "Council Room" : void 0, my.actions > 0 ? "Margrave" : void 0, my.actions > 0 ? "Smithy" : void 0, my.actions > 0 ? "Embassy" : void 0, my.actions > 0 ? "Merchant Ship" : void 0, my.actions > 0 ? "Pirate Ship" : void 0, my.actions > 0 ? "Saboteur" : void 0, my.actions > 0 ? "Noble Brigand" : void 0, my.actions > 0 ? "Thief" : void 0, my.actions > 0 ? "Monument" : void 0, my.actions > 0 ? "Feast" : void 0, "Conspirator", "Nobles", "Tribute", my.actions > 0 ? "Steward" : void 0, my.actions > 0 ? "Goons" : void 0, my.actions > 0 ? "Mine" : void 0, my.actions > 0 ? "Masquerade" : void 0, my.actions > 0 ? "Vault" : void 0, my.actions > 0 ? "Oracle" : void 0, my.actions > 0 ? "Cutpurse" : void 0, my.actions > 0 && my.countInHand("Copper") >= 2 ? "Coppersmith" : void 0, my.actions > 0 && this.wantsToTrash(state) ? "Ambassador" : void 0, "wait"].concat(this.old_actionPriority(state, my, skipMultipliers = true));
    };

    BasicAI.prototype.treasurePriority = function(state, my) {
      return ["Platinum", "Diadem", "Philosopher's Stone", "Gold", "Cache", "Hoard", "Royal Seal", "Harem", "Silver", "Fool's Gold", "Quarry", "Talisman", "Copper", "Potion", "Loan", "Venture", "Ill-Gotten Gains", "Bank", my.numUniqueCardsInPlay() >= 2 ? "Horn of Plenty" : void 0];
    };

    BasicAI.prototype.discardPriority = function(state, my) {
      return ["Tunnel", "Vineyard", "Colony", "Duke", "Duchy", "Fairgrounds", "Gardens", "Province", "Curse", "Estate"];
    };

    BasicAI.prototype.discardValue = function(state, card, my) {
      var myTurn;
      myTurn = state.current === my;
      if (card.name === 'Tunnel') {
        return 25;
      } else if (card.isAction && myTurn && ((card.actions === 0 && my.actionBalance() <= 0) || (my.actions === 0))) {
        return 20 - card.cost;
      } else {
        return 0 - card.cost;
      }
    };

    BasicAI.prototype.trashPriority = function(state, my) {
      return ["Curse", state.gainsToEndGame() > 4 ? "Estate" : void 0, my.getTotalMoney() > 4 ? "Copper" : void 0, my.turnsTaken >= 10 ? "Potion" : void 0, state.gainsToEndGame() > 2 ? "Estate" : void 0];
    };

    BasicAI.prototype.trashValue = function(state, card, my) {
      return 0 - card.vp - card.cost;
    };

    BasicAI.prototype.discardFromOpponentDeckValue = function(state, card, my) {
      if (card.name === 'Tunnel') {
        return -2000;
      } else if (!card.isAction && !card.isTreasure) {
        return -10;
      } else {
        return card.coins + card.cost + 2 * card.isAttack;
      }
    };

    BasicAI.prototype.discardHandValue = function(state, hand, my, nCards) {
      var deck, i, randomHand, total, _i;
      if (nCards == null) {
        nCards = 5;
      }
      if (hand === null) {
        return 0;
      }
      deck = my.discard.concat(my.draw);
      total = 0;
      for (i = _i = 0; _i < 5; i = ++_i) {
        shuffle(deck);
        randomHand = deck.slice(0, nCards);
        total += my.ai.compareByDiscarding(state, randomHand, hand);
      }
      return total;
    };

    BasicAI.prototype.gainOnDeckValue = function(state, card, my) {
      if (card.isAction || card.isTreasure) {
        return this.getChoiceValue('gain', state, card, my);
      } else {
        return -1;
      }
    };

    BasicAI.prototype.putOnDeckPriority = function(state, my) {
      var actions, byPlayValue, card, getChoiceValue, margin, putBack, treasures, _i, _j, _len, _len1, _ref;
      actions = (function() {
        var _i, _len, _ref, _results;
        _ref = my.hand;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          card = _ref[_i];
          if (card.isAction) {
            _results.push(card);
          }
        }
        return _results;
      })();
      getChoiceValue = this.getChoiceValue;
      byPlayValue = function(x, y) {
        return getChoiceValue('play', state, y, my) - getChoiceValue('play', state, x, my);
      };
      actions.sort(byPlayValue);
      putBack = actions.slice(my.countPlayableTerminals(state));
      if (putBack.length === 0) {
        treasures = [];
        _ref = my.hand;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          card = _ref[_i];
          if (card.isTreasure && (!(__indexOf.call(treasures, card) >= 0))) {
            treasures.push(card);
          }
        }
        treasures.sort(function(x, y) {
          return y.coins - x.coins;
        });
        margin = my.ai.coinLossMargin(state);
        for (_j = 0, _len1 = treasures.length; _j < _len1; _j++) {
          card = treasures[_j];
          if (my.ai.coinsDueToCard(state, card) <= margin) {
            putBack.push(card);
          }
        }
        if (my.countInPlay(state.cardInfo["Alchemist"]) > 0) {
          if (__indexOf.call(putBack, "Potion") >= 0) {
            putBack.remove(state.cardInfo["Potion"]);
          }
        }
      }
      if (putBack.length === 0) {
        putBack = [my.ai.choose('discard', state, my.hand)];
      }
      return putBack;
    };

    BasicAI.prototype.putOnDeckValue = function(state, card, my) {
      return this.discardValue(state, card, my);
    };

    BasicAI.prototype.reshuffleValue = function(state, choice, my) {
      var card, junkToDraw, proportion, totalJunk, _i, _j, _len, _len1, _ref, _ref1;
      junkToDraw = 0;
      totalJunk = 0;
      _ref = my.draw;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        card = _ref[_i];
        if (!(card.isAction || card.isTreasure)) {
          junkToDraw++;
        }
      }
      _ref1 = my.getDeck();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        card = _ref1[_j];
        if (!(card.isAction || card.isTreasure)) {
          totalJunk++;
        }
      }
      if (totalJunk === 0) {
        return 1;
      }
      proportion = junkToDraw / totalJunk;
      return proportion - 0.5;
    };

    BasicAI.prototype.trashOppTreasureValue = function(state, card, my) {
      if (card === 'Diadem') {
        return 5;
      }
      return card.cost;
    };

    BasicAI.prototype.ambassadorPriority = function(state, my) {
      var card;
      return ["[Curse, 2]", "[Curse, 1]", "[Curse, 0]", "[Ambassador, 2]", "[Estate, 2]", "[Estate, 1]", my.getTreasureInHand() < 3 && my.getTotalMoney() >= 5 ? "[Copper, 2]" : void 0, my.getTreasureInHand() >= 5 ? "[Copper, 2]" : void 0, my.getTreasureInHand() === 3 && my.getTotalMoney() >= 7 ? "[Copper, 2]" : void 0, my.getTreasureInHand() < 3 && my.getTotalMoney() >= 4 ? "[Copper, 1]" : void 0, my.getTreasureInHand() >= 4 ? "[Copper, 1]" : void 0, "[Estate, 0]", "[Copper, 0]", "[Potion, 2]", "[Potion, 1]", null].concat(((function() {
        var _i, _len, _ref, _results;
        _ref = my.ai.trashPriority(state, my);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          card = _ref[_i];
          if (card != null) {
            _results.push("[" + card + ", 1]");
          }
        }
        return _results;
      })()).concat((function() {
        var _i, _len, _ref, _results;
        _ref = my.hand;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          card = _ref[_i];
          _results.push("[" + card + ", 0]");
        }
        return _results;
      })()));
    };

    BasicAI.prototype.apprenticeTrashPriority = function(state, my) {
      "Border Village";
      "Mandarin";
      if (this.coinLossMargin(state) > 0) {
        "Ill-Gotten Gains";
      }
      "Feodum";
      "Estate";
      "Curse";
      return "Apprentice";
    };

    BasicAI.prototype.apprenticeTrashValue = function(state, card, my) {
      var coins, drawn, potions, vp, _ref;
      vp = card.getVP(my);
      _ref = card.getCost(state), coins = _ref[0], potions = _ref[1];
      drawn = Math.min(my.draw.length + my.discard.length, coins + 2 * potions);
      return this.choiceToValue('trash', state, card) + 2 * drawn - vp;
    };

    BasicAI.prototype.baronDiscardPriority = function(state, my) {
      return [true];
    };

    BasicAI.prototype.bishopTrashPriority = function(state, my) {
      return ["Farmland", this.goingGreen(state) < 3 ? "Duchy" : void 0, "Border Village", "Mandarin", "Feodum", "Bishop", this.coinLossMargin(state) > 0 ? "Ill-Gotten Gains" : void 0, "Curse"];
    };

    BasicAI.prototype.bishopTrashValue = function(state, card, my) {
      var coins, potions, value, _ref;
      _ref = card.getCost(state), coins = _ref[0], potions = _ref[1];
      value = Math.floor(coins / 2) - card.getVP(my);
      if (this.goingGreen(state) >= 3) {
        return value;
      } else {
        if (__indexOf.call(this.trashPriority(state, my), card) >= 0) {
          value += 1;
        }
        if (card.isAction && ((card.actions === 0 && my.actionBalance() <= 0) || (my.actions === 0))) {
          value += 1;
        }
        if (card.isTreasure && card.coins > (this.coinLossMargin(state) + 1)) {
          value -= 10;
        }
        return value;
      }
    };

    BasicAI.prototype.envoyValue = function(state, card, my) {
      var opp;
      opp = state.current;
      if (card.name === 'Tunnel') {
        return -25;
      } else if (!card.isAction && !card.isTreasure) {
        return -10;
      } else if (opp.actions === 0 && card.isAction) {
        return -5;
      } else if (opp.actions >= 2) {
        return card.cards + card.coins + card.cost + 2 * card.isAttack;
      } else {
        return card.coins + card.cost + 2 * card.isAttack;
      }
    };

    BasicAI.prototype.foolsGoldTrashPriority = function(state, my) {
      if (my.countInHand(state.cardInfo["Fool's Gold"]) === 1 && my.ai.coinLossMargin(state) >= 1) {
        return [true];
      } else {
        return [false];
      }
    };

    BasicAI.prototype.gainCopperPriority = function(state, my) {
      return [false];
    };

    BasicAI.prototype.herbalistValue = function(state, card, my) {
      return this.mintValue(state, card, my);
    };

    BasicAI.prototype.islandPriority = function(state, my) {
      return ["Colony", "Province", "Fairgrounds", "Duchy", "Duke", "Gardens", "Vineyard", "Estate", "Copper", "Curse", "Island", "Tunnel"];
    };

    BasicAI.prototype.islandValue = function(state, card, my) {
      return this.discardValue(state, card, my);
    };

    BasicAI.prototype.librarySetAsideValue = function(state, card, my) {
      return [my.actions === 0 && card.isAction ? 1 : -1];
    };

    BasicAI.prototype.miningVillageTrashValue = function(state, choice, my) {
      if (this.goingGreen(state) && this.coinGainMargin(state) <= 2) {
        return 1;
      } else {
        return -1;
      }
    };

    BasicAI.prototype.minionDiscardValue = function(state, choice, my) {
      var opponent, value;
      if (choice === true) {
        value = this.discardHandValue(state, my.hand, my, 4);
        opponent = state.players[state.players.length - 1];
        if (opponent.hand.length > 4) {
          value += 2;
        }
        return value;
      } else {
        return 0;
      }
    };

    BasicAI.prototype.mintValue = function(state, card, my) {
      return card.cost - 1;
    };

    BasicAI.prototype.oracleDiscardValue = function(state, cards, my) {
      var deck, randomCards;
      deck = my.discard.concat(my.draw);
      shuffle(deck);
      randomCards = deck.slice(0, cards.length);
      return my.ai.compareByDiscarding(state, my.hand.concat(randomCards), my.hand.concat(cards));
    };

    BasicAI.prototype.pirateShipPriority = function(state, my) {
      return [state.current.mats.pirateShip >= 5 && state.current.getAvailableMoney() + state.current.mats.pirateShip >= 8 ? 'coins' : void 0, 'attack'];
    };

    BasicAI.prototype.salvagerTrashPriority = function(state, card, my) {
      return ["Border Village", "Mandarin", this.coinLossMargin(state) > 0 ? "Ill-Gotten Gains" : void 0, "Feodum", "Salvager"];
    };

    BasicAI.prototype.salvagerTrashValue = function(state, card, my) {
      var buyState, coins, gained, hypothesis, hypothetically_my, potions, _ref, _ref1;
      _ref = state.hypothetical(this), hypothesis = _ref[0], hypothetically_my = _ref[1];
      hypothetically_my.hand.remove(card);
      _ref1 = card.getCost(hypothesis), coins = _ref1[0], potions = _ref1[1];
      hypothetically_my.coins += coins;
      hypothetically_my.buys += 1;
      buyState = this.fastForwardToBuy(hypothesis, hypothetically_my);
      gained = buyState.getSingleBuyDecision();
      return this.upgradeValue(state, [card, gained], my);
    };

    BasicAI.prototype.schemeValue = function(state, card, my) {
      var key, myNext, value;
      myNext = {};
      for (key in my) {
        value = my[key];
        myNext[key] = value;
      }
      myNext.actions = 1;
      myNext.buys = 1;
      myNext.coins = 0;
      return this.getChoiceValue('multiplied', state, card, myNext);
    };

    BasicAI.prototype.scryingPoolDiscardValue = function(state, card, my) {
      if (!card.isAction) {
        return 2000;
      } else {
        return this.choiceToValue('discard', state, card);
      }
    };

    BasicAI.prototype.spiceMerchantTrashPriority = function(state, my) {
      return ["Copper", "Potion", "Loan", "Ill-Gotten Gains", my.countInDeck("Fool's Gold") === 1 ? "Fool's Gold" : void 0, my.getTotalMoney() >= 8 ? "Silver" : void 0, null, "Silver", "Venture", "Cache", "Gold", "Harem", "Platinum"];
    };

    BasicAI.prototype.stablesDiscardPriority = function(state, my) {
      return ["Copper", my.countInPlay(state.cardInfo["Alchemist"]) === 0 ? "Potion" : void 0, "Ill-Gotten Gains", "Silver", "Horn of Plenty", null, "Potion", "Venture", "Cache", "Gold", "Platinum"];
    };

    BasicAI.prototype.tournamentDiscardPriority = function(state, my) {
      return [true];
    };

    BasicAI.prototype.transmuteValue = function(state, card, my) {
      if (card.isAction && this.goingGreen(state)) {
        return 10;
      } else if (card.isAction && card.isVictory && card.cost <= 4) {
        return 1000;
      } else {
        return this.choiceToValue('trash', state, card);
      }
    };

    BasicAI.prototype.wishValue = function(state, card, my) {
      var pile;
      pile = my.draw;
      if (pile.length === 0) {
        pile = my.discard;
      }
      return countInList(pile, card);
    };

    BasicAI.prototype.torturerPriority = function(state, my) {
      return [state.countInSupply("Curse") === 0 ? 'curse' : void 0, my.ai.wantsToDiscard(state) >= 2 ? 'discard' : void 0, my.hand.length <= 1 ? 'discard' : void 0, my.trashingInHand() > 0 ? 'curse' : void 0, my.hand.length <= 3 ? 'curse' : void 0, 'discard', 'curse'];
    };

    BasicAI.prototype.cardInDeckValue = function(state, card, my) {
      var endgamePower;
      endgamePower = 1;
      if (state.gainsToEndGame() <= 5) {
        endgamePower = 3;
      }
      return -(this.choiceToValue('trash', state, card)) + Math.pow(this.choiceToValue('gain', state, card), endgamePower);
    };

    BasicAI.prototype.upgradeValue = function(state, choice, my) {
      var newCard, oldCard;
      oldCard = choice[0], newCard = choice[1];
      return my.ai.cardInDeckValue(state, newCard, my) - my.ai.cardInDeckValue(state, oldCard, my);
    };

    BasicAI.prototype.chooseOrderOnDeck = function(state, cards, my) {
      var choice, sorter;
      sorter = function(card1, card2) {
        return my.ai.choiceToValue('discard', state, card1) - my.ai.choiceToValue('discard', state, card2);
      };
      choice = cards.slice(0);
      return choice.sort(sorter);
    };

    BasicAI.prototype.benefitValue = function(state, choice, my) {
      var actionBalance, actionValue, buyValue, cardValue, coinValue, trashValue, usableActions, value, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      buyValue = 1;
      cardValue = 2;
      coinValue = 3;
      trashValue = 4;
      actionValue = 10;
      actionBalance = my.actionBalance();
      usableActions = Math.max(0, -actionBalance);
      if (actionBalance >= 1) {
        cardValue += actionBalance;
      }
      if (my.ai.wantsToTrash(state) < ((_ref = choice.trash) != null ? _ref : 0)) {
        trashValue = -4;
      }
      value = cardValue * ((_ref1 = choice.cards) != null ? _ref1 : 0);
      value += coinValue * ((_ref2 = choice.coins) != null ? _ref2 : 0);
      value += buyValue * ((_ref3 = choice.buys) != null ? _ref3 : 0);
      value += trashValue * ((_ref4 = choice.trash) != null ? _ref4 : 0);
      value += actionValue * Math.min((_ref5 = choice.actions) != null ? _ref5 : 0, usableActions);
      return value;
    };

    BasicAI.prototype.wantsToTrash = function(state) {
      var card, my, trashableCards, _i, _len, _ref;
      my = this.myPlayer(state);
      trashableCards = 0;
      _ref = my.hand;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        card = _ref[_i];
        if (this.chooseTrash(state, [card, null]) === card) {
          trashableCards += 1;
        }
      }
      return trashableCards;
    };

    BasicAI.prototype.wantsToDiscard = function(state) {
      var card, discardableCards, my, _i, _len, _ref;
      my = this.myPlayer(state);
      discardableCards = 0;
      _ref = my.hand;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        card = _ref[_i];
        if (this.chooseDiscard(state, [card, null]) === card) {
          discardableCards += 1;
        }
      }
      return discardableCards;
    };

    BasicAI.prototype.multiplierChoices = function(state) {
      var card, choices, mult, mults, my;
      my = this.myPlayer(state);
      mults = (function() {
        var _i, _len, _ref, _results;
        _ref = my.hand;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          card = _ref[_i];
          if (card.isMultiplier) {
            _results.push(card);
          }
        }
        return _results;
      })();
      if (mults.length > 0) {
        mult = mults[0];
        choices = (function() {
          var _i, _len, _ref, _results;
          _ref = my.hand;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            card = _ref[_i];
            if (card.isAction) {
              _results.push(card);
            }
          }
          return _results;
        })();
        choices.remove(mult);
        choices.push(null);
        return choices;
      } else {
        return [];
      }
    };

    BasicAI.prototype.okayToPlayMultiplier = function(state) {
      var choices;
      choices = this.multiplierChoices(state);
      if (this.choose('multiplied', state, choices) != null) {
        return true;
      } else {
        return false;
      }
    };

    BasicAI.prototype.wantsToPlayMultiplier = function(state) {
      var choice, choices, multipliedValue, my, unmultipliedValue;
      my = this.myPlayer(state);
      choices = this.multiplierChoices(state);
      if (choices.length > 1) {
        choice = this.choose('multiplied', state, choices);
        multipliedValue = this.getChoiceValue('multiplied', state, choice, my);
        if ((choice != null) && choice.isMultiplier) {
          unmultipliedValue = 0;
        } else {
          unmultipliedValue = this.getChoiceValue('play', state, choice, my);
        }
        return multipliedValue > unmultipliedValue;
      }
      return false;
    };

    BasicAI.prototype.goingGreen = function(state) {
      var bigGreen, my;
      my = this.myPlayer(state);
      bigGreen = my.countInDeck("Colony") + my.countInDeck("Province") + my.countInDeck("Duchy");
      return bigGreen;
    };

    BasicAI.prototype.pessimisticMoneyInHand = function(state) {
      var buyPhase;
      if (state.depth > 0) {
        return this.myPlayer(state).getAvailableMoney();
      }
      buyPhase = this.pessimisticBuyPhase(state);
      return buyPhase.current.coins;
    };

    BasicAI.prototype.pessimisticBuyPhase = function(state) {
      var hypothesis, hypothetically_my, _ref;
      if (state.depth > 0) {
        if (state.phase === 'action') {
          state.phase = 'treasure';
        } else if (state.phase === 'treasure') {
          state.phase = 'buy';
        }
      }
      _ref = state.hypothetical(this), hypothesis = _ref[0], hypothetically_my = _ref[1];
      return this.fastForwardToBuy(hypothesis, hypothetically_my);
    };

    BasicAI.prototype.fastForwardToBuy = function(state, my) {
      var oldDiscard, oldDraws;
      if (state.depth === 0) {
        throw new Error("Can only fast-forward in a hypothetical state");
      }
      oldDraws = my.draw.slice(0);
      oldDiscard = my.discard.slice(0);
      my.draw = [];
      my.discard = [];
      while (state.phase !== 'buy') {
        state.doPlay();
      }
      my.draw = oldDraws;
      my.discard = oldDiscard;
      return state;
    };

    BasicAI.prototype.pessimisticCardsGained = function(state) {
      var newState;
      newState = this.pessimisticBuyPhase(state);
      newState.doPlay();
      return newState.current.gainedThisTurn;
    };

    BasicAI.prototype.coinLossMargin = function(state) {
      var cardToBuy, coins, coinsCost, newState, potionsCost, _ref;
      newState = this.pessimisticBuyPhase(state);
      coins = newState.current.coins;
      cardToBuy = newState.getSingleBuyDecision();
      if (cardToBuy === null) {
        return 0;
      }
      _ref = cardToBuy.getCost(newState), coinsCost = _ref[0], potionsCost = _ref[1];
      return coins - coinsCost;
    };

    BasicAI.prototype.coinGainMargin = function(state) {
      var baseCard, cardToBuy, coins, increment, newState, _i, _len, _ref;
      newState = this.pessimisticBuyPhase(state);
      coins = newState.current.coins;
      baseCard = newState.getSingleBuyDecision();
      _ref = [1, 2, 3, 4, 5, 6, 7, 8];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        increment = _ref[_i];
        newState.current.coins = coins + increment;
        cardToBuy = newState.getSingleBuyDecision();
        if (cardToBuy !== baseCard) {
          return increment;
        }
      }
      return Infinity;
    };

    BasicAI.prototype.coinsDueToCard = function(state, card) {
      var aCard, banks, c, nonbanks, value;
      c = state.cardInfo;
      value = card.getCoins(state);
      if (card.isTreasure) {
        banks = state.current.countInHand(state.cardInfo.Bank);
        value += banks;
        if (card === state.cardInfo.Bank) {
          nonbanks = ((function() {
            var _i, _len, _ref, _results;
            _ref = state.current.hand;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              aCard = _ref[_i];
              if (aCard.isTreasure) {
                _results.push(aCard);
              }
            }
            return _results;
          })()).length;
          value += nonbanks;
        }
      }
      return value;
    };

    BasicAI.prototype.compareByDiscarding = function(state, hand1, hand2) {
      var counter, discard1, discard2, savedActions, value1, value2;
      hand1 = hand1.slice(0);
      hand2 = hand2.slice(0);
      savedActions = state.current.actions;
      state.current.actions = 1;
      counter = 0;
      while (true) {
        counter++;
        if (counter >= 100) {
          throw new Error("got stuck in a loop");
        }
        discard1 = this.choose('discard', state, hand1);
        value1 = this.choiceToValue('discard', state, discard1);
        discard2 = this.choose('discard', state, hand2);
        value2 = this.choiceToValue('discard', state, discard2);
        if (value1 > value2) {
          hand1.remove(discard1);
        } else if (value2 > value1) {
          hand2.remove(discard2);
        } else {
          hand1.remove(discard1);
          hand2.remove(discard2);
        }
        if (hand1.length <= 2 && hand2.length <= 2) {
          state.current.actions = savedActions;
          return 0;
        }
        if (hand1.length <= 2) {
          state.current.actions = savedActions;
          return -1;
        }
        if (hand2.length <= 2) {
          state.current.actions = savedActions;
          return 1;
        }
      }
    };

    BasicAI.prototype.copy = function() {
      var ai, key, value;
      ai = new BasicAI();
      for (key in this) {
        value = this[key];
        ai[key] = value;
      }
      ai.name = this.name + '*';
      return ai;
    };

    BasicAI.prototype.cachedActionPriority = function(state, my) {
      return my.ai.cachedAP;
    };

    BasicAI.prototype.cacheActionPriority = function(state, my) {
      return this.cachedAP = my.ai.actionPriority(state, my);
    };

    BasicAI.prototype.toString = function() {
      return this.name;
    };

    return BasicAI;

  })();

  this.BasicAI = BasicAI;

  countInList = function(list, elt) {
    var count, member, _i, _len;
    count = 0;
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      member = list[_i];
      if (member === elt) {
        count++;
      }
    }
    return count;
  };

  stringify = function(obj) {
    if (obj === null) {
      return null;
    } else {
      return obj.toString();
    }
  };

  shuffle = function(v) {
    var i, j, temp;
    i = v.length;
    while (i) {
      j = parseInt(Math.random() * i);
      i -= 1;
      temp = v[i];
      v[i] = v[j];
      v[j] = temp;
    }
    return v;
  };

}).call(this);
